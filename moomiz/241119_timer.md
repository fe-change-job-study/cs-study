# 타이머 🔥

## 호출 스케쥴링이 무엇인가요?
 - Scheduling a call: 함수가 바로 호출되지 않고, 일정 시간이 지난 후 호출 되도록 함수 호출을 예약하는 것, 타이머 함수를 사용한다.  
## 타이머 함수에는 어떤 것들이 있나요?
 - 타이머 생성 함수: setTimeout, setInterval - 일정 시간이 지난 후 콜백 함수가 호출되도록 타이머 생성
   - setTImeout : 대기시간 이후 콜백함수 호출됨. 단 한번 동작한다. 
    ```
    let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
  
    ```
      - func|code : 호출할 콜백 함수 (문자열도 가능하나 권장하지 않음)
      - delay: 실행전 대기 시간, 단위 ms, 기본값 0
      - arg1~: 콜백함수에 전달할 인수 (IE9 이하 전달불가)
      - 반환 값: 타이머 식별을 위한 고유 타이머 id  (브라우저: 숫자, Node.js 객체)
        
   - setInterval : 대기시간마다 콜백함수 반복 호출 됨. 주기적으로 반복 동작.
    ```
    let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)- 인수는 setTimeout과 동일
    ```
    - 인수는 setTimeout과 동일
      
 - 타이머 제거 함수: clearTimeout, clearInterval
   - clearTimeout : 호출스케쥴링을 취소함 (타이머 취소)
     ```
      clearTimeout(timerId)
     ```
     - timerId : setTimeout 함수가 반환한 타이머 id 
   - clearInterval : 호출스케쥴링을 취소함 (타이머 취소)
     ```
      clearInterval(timerId) 
     ```
     - 인수는 clearTimeout과 동일 
     
## 이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우에 할 수 있는 어떤 일을 통해 해결할 수 있나요?
   짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지한다. 

## 디바운스에 대해서 알고 있나요?

 debounce: 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정시간이 경과한 이후에 이벤트 핸들러가 한번만 호출되도록 한다. 
 => 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다. 
 원리 : 사용자의 입력 여부를 정확히 알 수 없으므로 일정시간 동안 텍스트 입력 필드에 값을 입력하지 않으면 입력이 완료된 것으로 간주한다.
 이를 위해 debounce 함수가 반환한 함수는 debounce 함수에 두 번째 인수로 전달한 시간(delay)

## 쓰로틀에 대해서 알고 있나요?

throttle : 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출 되도록 한다. 
즉, 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.

