# prepare_frontend_interview

## HTML/ CSS

<b>프론트엔드 기술 면접을 위한 핸드북 만들기</b>

## HTML 목차

- [DOCTYPE 🔥](#DOCTYPE)

  - DOCTYPE에 대하여 설명하시오
  - meta 태그에 대해서 알고 있나요?
  - meta 태그의 요소에 대해서 아는대로 말해보세요

- [웹 표준 및 웹 접근성 🔥](#웹-표준-및-웹-접근성)

  - 웹 표준이란?
  - HTML5에서 추가된 내용이 있나요?
  - 웹 접근성이란?
  - 웹 접근성에 맞는 마크업 예시 몇가지 말해보시오
  - 시멘틱 태그란 무엇인가 왜 사용하는가
  - 텍스트 관련 태그
  - SEO란 무엇인가?
  - Button 태그의 Default type은 무엇인가?
  - Section 태그와 article 태그의 차이점
  - 크로스 브라우징이란 무엇인가요?

- [그 외 🔥](#그-외)

  - 이미지 크기가 클 경우 렌더링 속도가 느려질텐데 이를 개선하기 위한 방법
  - UI란 무엇인지 설명하시오
  - 이미지 태그에 src 속성을 사용하는 이유는 무엇인가?
  - 왜 일반적으로 CSS `<link>`를 head 태그 사이에 위치시키고, JS `<script>` 태그를 body 직전에 위치시키는 것이 좋은 방법인지 설명하시오
  - `data-속성` 은 무엇에 좋은지 설명하시오

- [SVG란?🔥](#SVG란)

  - SVG 장점과 단점
  - SVG 내부 도형에 대해 아는게 있나요?

## CSS 목차

- [display 🔥](#display)

  - block 이란?
  - inline 이란?
  - inline-block 이란?
  - none 이란?

- [position 속성에 대하여 🔥](#position-속성에-대하여)

  - static
  - relative
  - fixed
  - absolute

- [float가 어떻게 작동하는가🔥](#float가-어떻게-작동하는가)

- [Flexbox나 Grid 각각의 특징🔥](#Flexbox나-Grid-각각의-특징)

  - flex 를 사용하는 이유가 무엇인가요?
  - Grid를 사용하는 이유가 무엇인가요?

- [이미지 태그를 스타일로 대체하는 법 🔥](#이미지-태그를-스타일로-대체하는-법)

- [반응형 웹의 3요소 🔥](#반응형-웹의-3요소)

- [CSS selector가 어떠한 원리로 동작하나요? 🔥](#CSS-selector가-어떠한-원리로-동작하나요?)

- [반응형웹과 적응형웹에 설명하시오 🔥](#반응형웹과-적응형웹에-설명하시오)

  - 반응형 웹이란?
  - 적응형 웹이란?

- [PX, EM에 대해 설명하시오 🔥](#PX,-EM에-대해-설명하시오)

- [CSS 적용 우선순위 🔥](#CSS-적용-우선순위)

- [CSS-in-JS에 대해서 설명해 주세요 🔥](#CSS-in-JS에-대해서-설명해-주세요)

- [CSS 전처리기를 사용해보셨나요? 🔥](#CSS-전처리기를-사용해보셨나요)

  - 사용해봤다면 장점과 단점

- [padding과 margin의 차이가 무엇인가요? 🔥](#padding과-margin의-차이가-무엇인가요)

  - padding에 대하여
  - margin에 대하여

- [리플로우와 리페인트에 대해 설명하시오 🔥](#리플로우와-리페인트에-대해-설명하시오)
  - 리플로우에 대하여
  - 리페인트에 대하여

## 🎈 HTML

## DOCTYPE

### `DOCTYPE에 대하여 설명하시오`

브라우저가 문서를 렌더링할 때 어떤 종류의 문서인지를 설명해주는 것.

HTML의 버전을 명시한다.

### `meta 태그에 대해서 알고 있나요?`

메타 태그는 웹페이지가 담고 있는 컨텐츠가 아닌 **웹페이지 자체의 정보**를 명시하기 위한 목적으로 사용되는 HTML 태그이다.

`<meta>`요소를 통해서 마크업을 하며, HTML 문서 내에서 `<head>` 태그 사이에 위치한다. 따라서 웹페이지의 컨텐츠에는 아무런 영향도 미치지 않는다.

하지만 메타태그의 정보를 기반으로 Google 등의 검색엔진에서는 크롤러, 검색엔진 봇을 통해 웹페이지를 인덱싱하고, 검색 결과에 노출되는 순위를 결정하기 때문에 SEO에 영향을 크게 미치는 요소이다.

### `meta 태그의 요소에 대해서 아는대로 말해보세요`

`<meta name="속성" content="값">`

위 형식으로 메타태그를 사용하며 속성은 다음과 같은 태그들이 들어갈 수 있다.

#### title

페이지의 제목을 명시한다.

#### charset

페이지에서 사용되는 문자 인코딩을 명시한다.

#### viewport

페이지에서 권장하는 뷰포트 설정을 명시한다.

#### description

페이지에 대한 설명을 명시한다.

#### keywords

페이지에 대한 키워드를 명시한다.
이 키워드를 통해 해당 웹페이지의 관련 키워드를 나열할 수 있다.

#### author

페이지의 작성자를 명시한다.

#### robots

검색엔진 봇이 페이지를 인덱싱할 수 있도록 허용할지 말지를 명시한다.

#### og?

SNS나 메신저를 통해서 웹페이지의 링크를 공유할 때 페이지의 정보를 명시한다.

슬랙이나 트위터에서 해당 웹페이지의 링크를 공유한다면 콘텐츠 미리보기에 원하는 내용을 표기할 수 있다.

Open Graph Protocol이라는 업계표준을 따라서 정보를 제공하기 때문에 줄여서 og 태그라고 부른다.

<br />

## 웹 표준 및 웹 접근성

### `웹 표준이란?`

**웹 상에서 표준적으로 사용되는 기술 규격**

웹 표준은 웹사이트를 어떠한 운영체제에서나 어떠한 브라우저에서나 동일하게 보여지도록 W3C(World Wide Web Consortium) 기구 표준에 맞추는 것이다.

웹 표준의 최신 버전은 `HTML5`, `CSS3`이다.

### `HTML5에서 추가된 내용이 있나요?`

- canvas

  캔버스 태그는 자바스크립트를 통해 다양한 그림을 그릴 수 있는 공간을 제공한다.

  픽셀 기반의 비트맵 이미지를 그릴 수 있으며, 그래프, 게임 그래픽, 기타 실시간 이미지를 그릴 수 있다.

  WebGL과 같은 3d 기술의 구현이 웹 브라우저를 통해서도 가능해졌다.

- 다른 의미요소들
  - header
  - footer
  - article
  - section
  - nav
  - aside
  - etc

### `웹 접근성이란?`

시멘틱 태그를 통해서 모든 사람이 차별 없이 웹페이지를 자유롭게 이용할 수 있도록 하는 것.

aria-label, aria-hidden 등의 속성을 통해 웹 접근성을 높일 수 있다. ARIA(Accessible Rich Internet Applications)태그는 HTML 요소에 추가적인 의미를 부여하는 속성이다. 스크린 리더기를 통해 해당 요소가 어떻게 구성되어 있는지 알 수 있다.

### `웹 접근성에 맞는 마크업 **예시 몇가지 말해보시오`

1. 이미지는 사진이라 음성으로 들려줄 수 없지만 alt, IR기법을 사용하여 대체텍스트를 제공

2. 동영상은 대본이나 자막을 제공하고 자동재생 금지

3. title을 사용해 a 태그에 대한 정보를 적절히 제공해야 함

4. input태그에는 적절한 label이 제공되어야 함

5. table에는 caption, summary, thead, tbody, th 등을 사용

6. 컨텐츠는 위에서 아래로 읽을 수 있는 선형구조이어야 함 (ex) 명확한 헤딩구조(h1~h6)

7. 키보드 접근성을 고려해야함. 포커스가 시각적으로 표시 되어야함

8. 건너뛰기 링크를 사용해 id 속성을 통해 메인컨텐츠로 바로 접근할 수 있도록 함

9. 적절한 색상대비. WCAG기준 일반 텍스트 4.5:1 이상 큰 텍스트 3:1 이상

10. 문서의 언어 설정. Html 태그에 lang 속성을 사용해 문서의 언어를 설정함

<br />

### `시멘틱 태그란 무엇인가 왜 사용하는가`

의미요소(Sementic Element)는 HTML로 만든 문서에 추가적으로 의미를 부여해준다.

무의미한 요소로 문서를 작성할 경우, HTML문서를 접하는 사람이 어떤 데이터를 봐야할지, 어떤 데이터를 제공하는지 파악하기가 어렵다.

시멘틱 태그를 사용함으로써 서로 관계가 있는 정보를 파악하고 콘텐츠가 어떤 맥락 안에 있는지 알기 쉽게 해준다.

시멘틱 태그를 잘 지킨다면 검색엔진을 통해 검색이 잘 될 수 있도록 도와준다.

### `텍스트 관련 태그`

#### 줄바꿈이 일어나는 태그

`<h1>~<h6>`

제목을 표시할 때 사용된다. 스크린 리더 사용자가 사용하는 탐색 기법은 제목에서 제목으로 옯겨가는 방식이기 때문에, 제목 단계를 뛰어넘으면 문서의 층위를 파악하기 어려울 수 있다. 그래서 제목 단계는 순차적으로 늘어나야 한다. 즉 h1 후에 h3이 오지 않도록 한다. 그리고 페이지당 하나의 h1 태그만을 사용하자.

`<hr>`

수평줄이 생긴다. '주제가 바뀔 때' 분위기 전환을 위해서 넣는다. 이 글의 주제가 여기서 바뀌었다를 알리는 역할이다.

`<pre>`

표시한 공백(스페이스바로 띄운 공간)이 그대로 표시된다. 여담으로 CSS에서 지정할 수 있는 white-space 속성의 'pre'값이 같은 의미를 갖는다.

`<blockquote>`

인용구를 표시할 때 사용한다. 주로 블로그 글에서 인용구를 표시할 때 사용한다.

`<p>`

단락을 표시할 때 사용한다. 단락 중간에 줄바꿈이 일어나지 않는다.

#### 줄바꿈이 일어나지 않는 태그

`<strong>`

태그 안쪽 텍스트가 '중요한 내용'임을 의미하며, 글자를 굵게 표시한다.

`<b>`

중요하다는 의미를 가지지 않으면서, 글자를 굵게 표시한다.

`<em>`

'강조하고자 하는 내용'임을 의미하며, 글자를 기울여 표시한다.

`<i>`

특정한 의미를 담지 않고, 단순히 글자를 기울여 표시하고 싶을 때 사용한다.

`<q>`

단락과 문장 중간에 줄바꿈 없이 '인용문'을 표시할 때 사용한다. 태그로 묶은 내용 앞뒤에 따옴표가 붙는다.

`<mark>`

문장에 형광펜을 긋는 것처럼, 강조하고 싶은 부분을 태그로 묶으면 안쪽 텍스트 배경색이 노란색으로 표시된다. 텍스트의 중요성보다는, 검색 결과 표시 등 현재 맥락과 연관성이 있는 텍스트를 강조할 때 사용한다.

`<span>`

특정 텍스트에 스타일을 적용할 때 사용한다. 대표적으로 스타일을 적용하는 경우는 없다.

### `SEO란 무엇인가?`

`Search Engine Optimization` 검색 엔진 최적화

검색 엔진이 웹페이지에 대한 정보를 수집하고, 순위를 매겨서 검색결과에 노출되는 순위를 정하는 데, 이 때 헤더쪽에 웹페이지에 대한 정보를 명시해주면 검색 결과에 노출될 수 있는 순위를 높일 수 있다.

보통 `<head>` 태그 안에 메타 태그를 넣어주는 것이 일반적이다.

`Open Graph Protocol`

해당 프로토콜을 이용하면 SNS나 메신저를 통해서 웹페이지의 링크를 공유할 때 페이지의 정보를 명시할 수 있다.

### `Button 태그의 Default type은 무엇인가?`

submit이다. form 태그 안에 form data와 관련 없는 버튼을 만든 후 그 버튼을 누른다면 form의 submit 이벤트가 발생한다. 따라서 버튼 태그는 꼭 type을 명시하자.

### `Section 태그와 article 태그의 차이점`

- `article`: 문서나 사이트에서 독립된 컨텐츠 영역을 지정한다. 이 부분을 다른 곳에 옮기더라도 분리되어지고, 의미가 통해야한다.

- `section`: 페이지의 주요부분을 의미하며, 긴 글의 세부사항과 같은 관련 컨텐츠의 묶음, 또는 탭 키 사용을 요하는 인터페이스를 가진 웹 어플리케이션에서의 페이지의 묶음 단위를 의미한다.

<br />

### `크로스 브라우징이란 무엇인가요?`

크로스 브라우징이란 웹 사이트 또는 웹 응용 프로그램이 서로 다른 웹브라우저에서 정확하고 일관성 있게 작동하는 것을 의미한다.

여기에는 구글 크롬, 모질라 파이어폭스, 사파리, 마이크로소프트 엣지와 같은 인기 있는 브라우저의 다양한 버전과 오페라와 같은 덜 사용되는 브라우저가 포함된다.

주로 크롬과 사파리에서 크로스 브라우징, 스타일 문제가 발생한다.

브라우저에 따라서 렌더링 엔진이 다르기 때문에 브라우저마다 표준과 동작이 다르다.

마주했던 에러의 예시로는 canvas 요소의 최대 크기 문제가 있었다.

모바일 브라우저 별로 최대 크기가 다르기 때문에 페이지 전체를 캡쳐했을때 blob 형식으로 변환했을때 Null 값이 반환되는 문제가 있었다.

<br />

## 그 외 🔥

### 이미지 크기가 클 경우 렌더링 속도가 느려질텐데 이를 개선하기 위한 방법

1. 용량을 줄인다.
2. 최적화된 이미지 타입인 webp를 사용한다.
3. 이미지 스프라이트를 활용한다.
4. 벡터 이미지(SVG)를 활용한다.

하지만 SVG의 경우 이미지가 복잡한 사진같은 경우 오히려 그리는데 연산과정이 늘어나 성능 저하가 일어날 수 있다.

간단하게 설명하자면 webp, jpeg는 도장을 파서 한 번 찍는 느낌이라면, SVG는 붓으로 일일이 그림을 그린다고 생각하면 된다.

간단한 아이콘 같은 경우에는 붓질 몇번이 도장을 파는 것 보다 빠르지만, 복잡한 사진의 경우에는 손으로 그리는 게 더 느린 것과 같은 이치.

레스터 이미지(webp, jpeg, png)
- 픽셀 단위로 색상 정보를 저장
- 미리 계산된 픽셀 데이터를 표시
- 확대시 품질 저하 발생
- 사진과 같은 복잡한 이미지에 적합

SVG
- 수학적 계산을 통해 이미지를 그리는 방식
- 도형, 선, 곡선 좌표와 수식으로 표현
- 크기를 변경해도 품질 손실이 없음
- 간단한 도형, 아이콘, 로고에 적합

#### SVG 내부 도형에 대해 아는게 있나요?

- `<rect>` - 사각형

 ```html
  <rect x="10" y="10" width="30" height="30" />
  <rect x="60" y="10" rx="10" ry="10" width="30" height="30" />
  ```

x - 사각형 좌측 상단의 x 값을 의미

y - 사각형 좌측 상단의 y 값을 의미

width - 사각형의 폭을 나타낸다.

height - 사각형의 높이를 나타낸다.

rx - 사각형의 둥근 꼭짓점의 x 방향으로의 반지름이다.

ry - 사각형의 둥근 꼭짓점의 y 방향으로의 반지름이다.

<br />

- `<circle>` - 원


  ```html
  <circle cx="25" cy="75" r="20" />
  ```

r - 원의 반지름을 의미한다.

cx - 원의 중심중 x 값을 의미한다.

cy - 원의 중심 중 y 값을 의미한다.

<br />

- `<polyline>` - 연결된 직선의 그룹

  ```html
  <polyline
    points="60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145"
  />
  ```

points - 포인트들의 목록, 각 숫자는 공백, 쉼표, EOL 또는 줄바꿈 문자로 구분된다. 각 포인트는 반드시 x좌표와 y좌표를 가지고 있어야 한다. 따라서 포인트 목록 (0,0), (1,1) 및 (2,2)는 "0 0, 1 1, 2 2"라고 쓸 수 있다.

- `<path>` - 선과 곡선, 호 등 다양한 형태를 그릴 수 있는 가장 강력한 엘리먼트

### UI란 무엇인지 설명하시오

User Interface

유저가 직접 마주하는 웹사이트의 화면을 의미한다.

다양한 사용자가 사용할 수 있도록 보편성을 지녀야 하며 전체적으로 사용에 있어 큰 불편함이 없어야 한다.

### 이미지 태그에 src 속성을 사용하는 이유는 무엇인가?

이미지의 출처(source)를 지정하는 필수 속성.

브라우저에게 이미지 파일의 위치를 알려주는 역할이다. src 속성이 없으면 이미지를 표시할 수 없다.


### 왜 일반적으로 CSS `<link>`를 head 태그 사이에 위치시키고, JS `<script>` 태그를 body 직전에 위치시키는 것이 좋은 방법인지 설명하시오

#### CSS `<link>` 태그를 head 태그 사이에 위치시키는 이유

1. 렌더링 차단 방지
- CSS는 렌더링 차단 리소스
- 브라우저는 CSS를 모두 다운로드하고 파싱할 때까지 렌더링을 차단한다.
- head에 위치하면 브라우저는 빠르게 다운로드를 시작할 수 있다.

2. FOUC 방지
- CSS가 늦게 로드되면 스타일이 적용되지 않은 콘텐츠가 나타날 수 있다.

### `<script>` 태그를 body 직전에 위치시키는 이유

1. HTML 파싱 차단 방지
- 브라우저는 HTML을 파싱하다가 script 태그를 만나면 멈춘다.
- 따라서 script 태그를 body 직전에 위치시키면 브라우저는 HTML 파싱을 완료하고 렌더링을 시작할 수 있다.

2. DOM조작의 안정성
- JS가 조작하려는 DOM요소들이 모두 로드된 후 실행되어야 한다.

3. 페이지 로드 성능 향상
- 주요 콘텐츠를 먼저 표시
- JS 다운로드/실행으로 인한 지연 최소화

### `data-속성` 은 무엇에 좋은지 설명하시오

1. HTML 요소에 추가 데이터 저장
2. JS에서 접근이 가능
3. CSS에서 선택자로 사용 가능

<br />

## CSS 🔥

### display 🔥

#### block 이란?

항상 새로운 라인에 요소가 시작되고 화면 크기 전체 가로폭을 영역으로 차지한다. width 속성 값을 부여해주면 그 너비만큼 영역을 차지한다.

#### inline 이란?

새로운 라인에서 시작되지 않으며 다른 요소들과 같은 줄에 배치될 수 있고 content 너비만큼의 영역을 차지한다. 그리고 width, height, margin-top, margin-bottom 속성이 적용이 되지 않는다.

#### inline-block 이란?

block 레벨 요소와 inline 레벨 요소의 특징을 모두 가지고 있다. 한 줄에서 inline 레벨 요소들과 같이 배치될 수 있으며 width height 속성으로 영역의 크기를 지정할 수 있다.

#### none 이란?

아예 사라지게 하는것. 보이지도 않고 해당 공간도 존재하지 않게 된다.

<br />

### `position 속성에 대하여`

1. static : 기본 값으로 요소들이 겹치지 않고 상 -> 하로 배치된다.

2. relative : 원래 배치되어야 할 위치에서 지정한 값 만큼 떨어진 곳에 요소를 배치한다. 또한 abosulte의 부모요소에 이 속성을 지정할 경우 absolute의 기준점이 된다.

3. fixed : 웹 브라우저 화면 전체를 기준으로 배치한다. 스크롤을 하더라도 위치가 고정된다.

4. absolute : 가장 가까운 상위 요소의 위치를 기준으로 지정한 값만큼 떨어진 곳에 요소를 배치한다.

5. sticky : 스크롤 위치가 임계점에 이르면 position: fixed와 같이 박스를 화면에 고정할 수 있는 속성으로 스크롤 영역 기준으로 배치된다.

<br />

### `float 가 어떻게 작동하는가`

Float는 CSS 위치 지정 속성이다.

Float된 요소는 페이지 흐름의 일부가 되며, 페이지의 흐름에서 제거되는 position: absolute 요소와 달리 다른 요소 (ex: 플로팅 요소 주위로 흐르는 텍스트)의 위치에 영향을 준다.

CSS `clear` 속성은 float 요소에 left/right/both에 위치하도록 사용될 수 있다.

부모 요소에 float 요소만 있으면, 그 높이는 무효가 된다. 컨테이너의 float 요소 다음에 있지만 컨테이너가 닫히기 전에 float를 clear하면 해결할 수 있다.

<br />

### `Flexbox나 Grid 각각의 특징`

#### flex와 grid를 사용하는 이유

flex는 레이아웃을 좀 더 편하게 잡기 위해서 만들어진 css 속성이다.

flex를 사용하면 요소들의 크기나 위치를 쉽게 잡을 수 있다.

기존에 구조를 만들 때 사용하는 속성이 float나 inline-block 등이 있었는데 여러가지 문제를 가지고 있었고 flex를 사용하면 이러한 속성의 한계를 보완할 수 있다.

Float의 문제점
- 요소 겹침 현상
- 부모 높이 상실
- 유연한 크기 조절의 어려움

inline-block의 문제점
- 요소 간 원치 않는 공백 발생
- 수직 정렬의 어려움
- 반응형 레이아웃 구현의 한계

위와 같은 문제점을 Flex는
- justify-content, align-items, align-self 등의 속성
- flex: 1 과 같은 속성으로 균등하게 넓이 나누기
- order 속성으로 순서 변경
- flex-direction 속성으로 배치 방향 설정
- gap을 통해 간격 조절

등과 같은 설정으로 해결했다.

또한 Grid는
- 2차원 레이아웃 구성
- grid-template-rows, grid-template-columns 속성을 통해 행과 열의 개수 설정
- grid-template-areas 속성을 통해 각 셀의 크기 조절
- grid-area 속성을 통해 위치 지정

등의 설정으로 해결했다.

<br />

## 리플로우와 리페인트에 대해 설명하시오

브라우저의 작동 방식부터 설명을 하자.

브라우저는 최초로 렌더링을 시작할 때 HTML, CSS, 자바스크립트 파일을 불러온다.

HTML 파일은 DOM Tree로 변환, CSS 파일은 CSSOM Tree로 변환한다.

이후 DOM Tree와 CSSOM Tree를 합쳐 Render Tree를 만든다.

이 때 display:none, head 같은 태그는 렌더 트리에서 제외된다.

이후 Render Tree를 기반으로 렌더링을 시작한다. 이 과정을 Layout이라고 한다.

마지막으로 요소에 스타일을 적용하는 Paint 과정을 거친다.

이 때 레이아웃과 페인트 과정을 최초로 그린 다음 레이아웃과 페인트 과정을 다시 그리는 것을 리플로우와 리페인트라고 한다.

### 리플로우

리플로우는 요소의 크기, 위치, 레이아웃 등이 변경되어 렌더 트리를 재생성하는 작업이다.

발생시점은

1. DOM 요소의 기하학적 속성이 변경될 때
2. 브라우저의 사이즈가 변할때

위 두 가지 경우에 발생한다.

리플로우는 비용이 상당히 큰 작업이다. 특정 요소에서 리플로우가 발생하면 주변요소(부모, 자식, 형제)에게 영향을 주기 때문이다.

또한 위 두가지 경우 외에도 offsetWidth, offsetHeight, clientWidth, clientHeight, scrollWidth, scrollHeight 등의 속성이 변경되거나 조회할때 발생한다.
https://gist.github.com/paulirish/5d52fb081b3570c81e3a

### 리페인트

리페인트는 변경된 요소를 화면에 그려주는 작업을 의미한다.

발생시점은

1. 리플로우가 발생했을때
2. 요소의 스타일(background, color, border 등)이 변경될 때
3. visibility가 변경될 때

리페인트는 요소의 스타일이 변경되었을 때 발생하므로 리플로우보다 비용이 적다.

### 어떻게 하면 리플로우, 리페인트를 줄일 수 있을까?

#### 1. 애니메이션 요소의 위치를 absolute, fixed로 두기

애니메이션으로 요소의 위치를 변경할 때, 주변 요소의 위치도 변경되어 리플로우가 여러번 발생한다.

리플로우가 여러번 발생하지 않도록, 애니메이션이 적용된 요소의 position을 absolute, fixed로 두면 된다.

#### 2. display: none 을 사용하기

display: none이 적용된 요소는 렌더트리에서 제외된다. 따라서 요소의 여러 스타일이 변경되어야하는 경우에는 display: none을 설정하고, 스타일을 변경한 뒤, display: block으로 변경하면 리플로우, 리페인트를 줄일 수 있다.

#### 3. DOM 속성 변경 코드 모으기

JS에서 DOM 속성을 변경할 때, 여러번 변경하는 것보다 한번에 변경하는 것이 좋다.

```typescript
// BAD
const el1 = document.querySelector(".target-first");
el1.style.width = "10px";

const el2 = document.querySelector(".target-second");
el2.style.width = "10px";

const el3 = document.querySelector(".target-third");
el3.style.width = "10px";

// GOOD

const el1 = document.querySelector(".target-first");
const el2 = document.querySelector(".target-second");
const el3 = document.querySelector(".target-third");

// dom의 스타일 변경 코드를 한 곳으로 모아둠
el1.style.width = "10px";
el2.style.width = "10px";
el3.style.width = "10px";
```

브라우저의 리플로우 처리방식 때문

브라우저는 변경할 요소가 있을 때 즉시 처리하지 않고 큐에 저장한다.

큐에 변경 작업이 쌓였을 때 리플로우를 실행한다.

결국 DOM의 수저을 모아두면 이 수정코드가 큐에 쌓여있다 한번에 처리되기 때문에 리플로우 횟수를 줄일 수 있다.

#### 4. 리플로우 유발 함수의 호출을 제한하기

리플로우를 발생시키는 함수나 속성을 매변 호출하지 않고 변수에 저장한다.

#### 5. CSS로 스타일을 한 번에 변경하기

만약 DOM의 여러 스타일을 변경해야한다면, 스타일을 CSS클래스로 정의해두고 한번에 변경하자.

#### 6. 가상 DOM 사용하기

리액트나 뷰를 사용한다면 가상 DOM을 사용하기 때문에 리플로우, 리페인트를 줄일 수 있다.

가상 DOM은 생성한 DOM을 저장했다가 DOM에 변화가 있다면 메모리에 저장했던 DOM과 현재 변경된 DOM을 비고해 변경된 부분만 실제 DOM에 반영하기 때문이다.
