# prepare_frontend_interview

## Computer Science

## 목차

- [`네트워크 🔥`](#네트워크)

  - 네트워크에서 패킷이란 무엇을 의미하나요?
  - 네트워크에서 처리량은 무엇을 의미하나요?
  - 지연시간이란 무엇인가요?
  - 처리량은 어떤 상황에 영향을 받나요?
  - 네트워크 병목현상은 무엇인가요?
  - TCP/IP 가 무엇인가요 ? 각 계층에 대해서 설명할 수 있나요?
  - 전송 계층의 대표적인 방식은 무엇이 있고 어떤 차이가 있나요? (키워드: TCP, UDP)
  - 계층 간 데이터 송수신 과정에 대해 설명할 수 있나요? (키워드: 캡슐화, 비캡슐화)
  - 네트워크에서 PDU에 대해 알고 있나요?
  - 로드밸런서란 무엇인가요?
  - ARP란 무엇인가요?
  - MAC 주소란 무엇인가요?
  - NAT란 무엇인가요?

- [HTTP 🔥](#HTTP)

  - HTTP란 뭔가요?
  - HTTP 프로토콜의 가장 큰 특징은 뭔가요?
  - URL은 뭔가요?
  - HTTP/1.0 과 HTTP/1.1의 차이는 뭔가요?
  - HTTP/1.1 과 HTTP/2.0의 차이는 뭔가요?
  - HTTPS는 HTTP랑 뭐가 다른가요?
  - 심화) 공개키 (비대칭키) 방식이 뭔가요?

- [`운영체제 🔥`](#운영체제)

  - 운영체제란 무엇인가요?
  - 운영체제는 어떤 역할을 하나요?
  - 운영체제는 어떤 구조로 이루어져 있나요?
  - 컴퓨터는 어떤 요소로 이루어져 있나요?
  - CPU는 어떤 요소로 이루어져 있나요?
  - CPU는 어떻게 동작하나요?
  - 메모리란 무엇인가요?
  - 메모리는 어떤 계층 구조로 이루어져 있나요?
  - 메모리는 어떤 방식으로 데이터를 관리하나요?

- [프로세스와 스레드 🔥](#프로세스와-스레드)

  - 프로세스가 뭔가요?
  - 스레드가 뭔가요?
  - 프로세스와 스레드는 어떤 차이가 있나요?
  - 프로세스의 컴파일 과정에 대해 설명해줄 수 있나요?
  - 프로세스는 어떤 상태 값을 가지고 있나요?
  - 프로세스는 어떤 구조로 이루어져 있나요? (스택, 힙, 데이터 영역, 코드 영역)
  - PCB는 무엇인가요? 어떤 용도로 사용되나요? (메타 데이터)

- [싱글 스레드와 멀티 스레드 🔥](#싱글-스레드와-멀티-스레드)

  - 싱글 스레드 장점
  - 싱글 스레드 단점
  - 멀티 스레드 장점
  - 멀티 스레드 단점

- [공유 자원 임계 영역 교착 상태 🔥](#공유-자원-임계-영역-교착-상태)

  - 공유 자원
  - 임계 영역
  - 뮤텍스
  - 세마포어
  - 교착 상태

- [쿠키 세션 🔥](#쿠키-세션)

  - 쿠키, 세션을 왜 쓰나요?
  - 쿠키가 뭔가요?
  - 세션이 뭔가요?
  - 쿠키와 세션의 차이는 어떤 점이 있을까요?
  - JWT을 아나요?
  - JWT를 웹 스토리지에 저장해야 한다면 어디다 저장하시겠나요? 이유는요?

- [CORS 🔥](#CORS)

  - CORS가 뭔가요?
  - CORS를 겪고 직접 해결해 본 경험이 있으면 말해주세요

- [개발 방법론 🔥](#개발-방법론)

  - 소프트웨어 개발 주기(SDLC)에 대해 아나요?
  - 폭포수 방법론이란 뭔가요?
  - 애자일 방법론이란 뭔가요?

- [Cache 🔥](#Cache)

- 캐시란 무엇인가요?

- [CDN 🔥](#CDN)

  - CDN이란 뭔가요?

- [테스트 🔥](#테스트)

  - 테스트란 무엇인가요?
  - 테스트의 예는 어떤 것들이 있나요?
  - 테스트는 왜 해야 하나요?
  - 유닛 테스트란 무엇인가요?
  - 통합 테스트란 무엇인가요?
  - E2E 테스트란 무엇인가요?

- [웹팩 🔥](#웹팩)

  - 웹팩이란?
  - 모듈이란?
  - 모듈 번들링이란?
  - 웹팩이 등장한 이유 웹팩 사용 시에 이점
  - 바벨이란?
  - 웹팩의 주요 속성 4가지

- [타입과 인터페이스 🔥](#타입과-인터페이스)

  - 이 글을 보시는 분들께
  - 타입스크립트를 왜 쓰나요? (본인이 느낀점)
  - 타입과 인터페이스의 차이를 아나요? 🔥🔥🔥
  - 타입의 유틸리티 타입 중 알고 있는 것들에 대해 가볍게 설명해주세요
  - 제네릭이란? 🔥🔥🔥

## 네트워크

네트워크란 **노드와 링크가 서로 연결되어 있으며 리소스를 공유하는 집합**을 말한다. 여기서 노드란 서버, 라우터, 스위치 등 네트워크 장치를 의미하고 링크는 유선 또는 무선을 의미한다.

### `네트워크에서 패킷이란 무엇을 의미하나요?`

패킷 : 네트워크 데이터의 전송 단위

- 헤더
- 데이터
- 트레일러
  의 세 구조로 구성된다.

1. 헤더(Header): 20~60바이트
   - 목적지 주소 - 패킷이 전송되어야 할 대상의 네트워크 주소
   - 출발지 주소 - 패킷을 전송한 장치의 네으워크 주소
   - 프로토콜 정보 - 패킷에 담긴 데이터가 어떤 프로토콜(TCP, UDP 등)을 사용했는지 나타냄
   - 깊이 - 패킷의 크기
   - 기타정보 - 패킷 순서, 분할 여부 등
2. 데이터(Payload) 0-65, 535바이트
   - 실제 전송하고자 하는 데이터 콘텐츠
3. 트레일러(Trailer) 4바이트
   - 오류 검사 정보

네트워크 장비들은 이 패킷 구조를 이용해 데이터를 효율적으로 전송하고 처리한다. 패킷의 헤더 정보를 확인하여 데이터의 목적지와 프로토콜을 파악하고, 패킷을 중간에서 라우팅하거나 필터링할 수 있다. 또한 트레일러의 오류 검사 정보를 통해 패킷 전송의 무결성을 확인할 수 있다.

처리 과정은 다음과 같다.

1. 송신 측
   데이터 분할 -> 헤더추가 -> 트레일러 추가 -> 전송
2. 수신 측
   패킷 수신 -> 오류 검사 -> 헤더/트레일러 제거 -> 데이터 재조립

### `네트워크에서 처리량은 무엇을 의미하나요?`

처리량은 링크를 통해 전달되는 단위 시간당 데이터양을 의미.

단위로는 bps(bits per second)를 쓴다. 초당 전송 또는 수신되는 비트 수를 의미한다.

### `처리량은 어떤 상황에 영향을 받나요?`

처리량은 트래픽, 대역폭, 지연시간, 병목현상에 따라서 영향을 받게된다.

### `대역폭이란 무엇인가요?`

대역폭의 경우 보통 인터넷의 속도라고 할 수 있는 100Mbps, 1Gbps 등이 있다. 기가 인터넷이라고 하면 1Gbps를 의미한다. 따라서 대역폭이 높을 수 록 처리량이 높아지기 때문에 인터넷 속도가 빠르다는 것.

### `지연시간이란 무엇인가요?`

지연시간이란 요청이 처리되는 시간을 말하며 어떤 메세지가 두 장치 사이를 왕복하는데 걸린 시간을 의미한다. 지연 시간은 다음과 같은 상황에 영향을 받는다.

- 매체 타입(무선, 유선)
- 패킷 크기
- 라우터의 패킷 처리 시간

### `네트워크 병목현상은 무엇인가요?`

병목 현상이란 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상을 말한다.

서비스에서 이벤트를 열었을 때 트래픽이 많이 생기고 그 트래픽을 잘 관리하지 못하면 병목 현상이 생겨 사용자는 웹 사이트로 들어가지 못하는 상황이 발생할 수 있다.

이를 가장 쉽게 볼 수 있는 예시가 콘서트 예매 사이트.

트래픽이 몰리게 되면 서버가 요청에 대한 연산을 감당하지 못하게 되고, DB에 사용자의 요청이나 입력이 제대로 반영 되지 않는 상황이 발생한다.

자바의 경우 멀티스레드를 사용하여 어느정도 분산 처리가 가능하지만 노드 계열의 경우 자바스크립트는 싱글 스레드 엔진을 기반으로 실행하기 때문에 높은 트래픽의 경우 대응이 어려울 수 있다.

물론 멀티스레드가 만능이 아니기 때문에 서버의 성능이 낮다면 똑같이 문제가 발생할 수 있다.

이 때 해결법은 다음과 같다.

1. 수평적 확장
   - 단순히 처리할 수 있는 서버의 수를 늘리는 것.
   - 물론 이 방법은 비용이 많이 들기 때문에 최후의 수단으로 사용해야 한다.
   - 아니면 로드 밸런서를 통해서 부하를 분산시킬 수 있다.
   - 쿠버네티스를 사용할 수도 있다.
2. 수직적 확장

   - 서버의 성능을 올리는 것.
   - 물론 이 방법도 비용이 많이 들기 때문에 최후의 수단으로 사용해야 한다.

3. 캐싱 전략

   - Redis, Memcached 등의 캐시 서버를 활용
   - 자주 요청되는 데이터를 메모리에 임시 저장하여 빠른 응답 제공
   - 데이터베이스 부하를 줄이고 응답 시간을 개선
   - 예시: 상품 정보, 세션 데이터, API 응답 결과 등을 캐싱

4. 큐 시스템
   - RabbitMQ, Kafka 등의 메시지 큐 시스템을 활용
   - 대량의 요청을 순차적으로 큐에 저장하고 순서대로 처리
   - 서버 부하를 분산하고 안정적인 작업 처리를 보장
   - 예시: 결제 처리, 이메일 발송, 대용량 데이터 처리 등의 비동기 작업

### `TCP/IP 가 무엇인가요 ? 각 계층에 대해서 설명할 수 있나요?`

인터넷 프로토콜 스위트(Internet Protocol Suite)는 인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 프로토콜의 집합이며, 이를 TCP/IP 4계층 모델로 설명하거나 OSI 7계층 모델로 설명하기도 한다.

TCP/IP (Transmission COntrol Protocol)

- **이 계층들은 특정 계층이 변경되었을 때 다른 계층이 영향을 받지 않도록 설계되었다.**

### 애플리케이션 계층

애플리케이션 계층은 FTP, HTTP, SSH, SMTP, DNS 등 응용프로그램이 사용되는 프로토콜 계층이며, 웹 서비스, 이메일 등 서비스를 실질적으로 사람들에게 제공하는 층이다.

FTP

장치와 장치간의 파일을 전송하는데 사용되는 표준 통신 프로토콜

SSH

보안되지 않은 네트워크에서 네트워크 서비스를 안전하게 운영하기 위한 암호화 네트워크 프로토콜

주로 원격 서버 접속, 원격 명령 실행에 사용되며 기본포트는 22번 포트.

AWS의 EC2 인스턴스에 접속하는 경우 보통 SSH를 사용한다.

다른 예시로는 Git저장소 접근, 집에서 홈서버를 구축한 경우 원격으로 컴퓨터를 제어하는 등의 용도로 사용된다.

SSH는 공개키/개인키 쌍을 사용하여 인증을 수행하며, 데이터 전송 시 암호화를 통해 보안을 유지한다.

HTTP

World Wide Web을 위한 데이터 통신의 기초이자 웹 사이트를 이용하는데 쓰는 프로토콜

보안 인증서를 발급해서 사용하는 경우는 HTTPS(HTTP over SSL) 통신을 이용한다고 한다. 데이터 암호화를 통해 보안을 보장한다.

SMTP

전자 메일 전송을 위한 인터넷 표준 통신 프로토콜

DNS(Domain Name System)

도메인 이름과 IP주소를 매핑해주는 시스템, 기본적으로 통신은 ip주소를 통해서 이루어지지만 이를 외우기는 쉽지않다.

따라서 이를 해결하기 위해 의미있는 문자열의 나열인 도메인 이름을 사용하는 것.

해당 도메인 네임을 주소창에 치면

DNS 조회 과정:
1. 브라우저는 먼저 자체 DNS 캐시를 확인
2. OS의 DNS 캐시 확인 (hosts 파일 포함)
3. 로컬 DNS 서버(ISP DNS 서버)에 쿼리
4. 로컬 DNS 서버는 다음 순서로 조회:
   - 루트 DNS 서버에 쿼리
   - TLD(Top-Level Domain) DNS 서버에 쿼리
   - 권한 있는 DNS 서버에 쿼리
5. 찾은 IP 주소를 로컬 DNS 서버가 캐시하고 클라이언트에게 반환

### 전송 계층

전송 계층은 송신자와 수신자를 연결하는 통신 서비스를 제공하며 연결 지향 데이터 스트림 지원, 신회성, 흐름 제어를 제공할 수 있으며 애플리케이션과 인터넷 계층 사이의 데이터가 전달될 때 중계 역할을 한다. 대표적으로 TCP와 UDP가 있다.

TCP는 패킷 사이의 순서를 보장하고 연결지향 프로토콜을 사용해서 연결을 하여 신뢰성을 구축해서 수신 여부를 확인하며 '가상회선 패킷 교환 방식을'사용한다.

**가상회선 패킷 교환 방식**은 각 패킷에는 가상회선 식별자가 포함되며 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 '순서대로' 도착하는 방식을 말한다.

UDP는 순서를 보장하지 않고 수신 여부를 확인하지 않으며 단순히 데이터만 주는 '데이터그램 패킷 교환 방식'을 사용한다.

3-way handshaking과정을 통해 통신을 시작하고, 4-way handshaking과정을 통해 통신을 종료한다.

3-way handshaking (연결 시작)

해당 과정은 다음과 같다.
1. Clinet > Server: TCP SYN
2. Server > Client: TCP SYN ACK
3. Client > Server: TCP ACK

> SYN: Synchronize Sequence Numbers
>
> ACK: Acknowledgment

이 과정을 통해 양측이 데이터를 전송할 준비가 되었다는 것을 보장할 수 있다.

간단하게 말하자면 순차 일련번호를 주고받고 정확한지 검증하는 것.

4-way handshaking (연결 종료)

1. Client > Server: FIN
2. Server > Client: ACK
3. Server > Client: FIN
4. Client > Server: ACK

> FIN: Finish

이후 Client는 일정 시간(TIME_WAIT) 동안 대기한 후 연결을 완전히 종료한다.

**데이터그램 패킷 교환방식**은 패킷이 독립적으로 이동하며 최적의 경로를 선택하여 가는데, 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있으며 도착한 '순서가 다를 수' 있는 방식을 뜻한다.

### `전송 계층의 대표적인 방식은 무엇이 있고 어떤 차이가 있나요? (키워드: TCP, UDP)`

### `계층 간 데이터 송수신 과정에 대해 설명할 수 있나요? (키워드: 캡슐화, 비캡슐화)`

### `네트워크에서 PDU에 대해 알고 있나요?`

### `로드밸런서란 무엇인가요?`

### `ARP란 무엇인가요?`

### `MAC 주소란 무엇인가요?`

### `NAT란 무엇인가요?`

### `naver.com을 주소창에 치면 일어나는 일은 무엇인가요?`

<br />

## CORS

### CORS가 뭔가요?

CORS(Cross-Origin Resource Sharing)

웹에서 다른 도메인 혹은 포트 등에 대한 접근을 허용하는 정책.
보통 다른 도메인에서 리소스를 요청 할 때 발생한다.

정확히는 다른 오리진에서 리소스를 요청 할 때 발생한다.

> 오리진 vs 리소스?
>
> 오리진은 프로토콜(http, https), 호스트(www.example.com), 포트(443)를 포함한 전체 주소를 의미한다.
>
> 예: https://www.example.com:443
>
> 리소스는 오리진 이후의 경로와 파일을 의미한다.
> 예: /path/to/resource.html
>
> 전체 URL 예시: https://www.example.com:443/path/to/resource.html

브라우저에서만 나타나기 때문에 서버와 서버간의 통신에서는 발생하지 않는다. 따라서 외부 API를 사용할 때 프론트에서 직접 사용하는 것이 아닌 서버에서 처리하는 이유가 이것 때문일 수 있다.

앱에서는 CORS 정책이 직접적으로 적용되지 않지만, 앱 내 웹뷰를 사용하거나
네이티브 HTTP 요청을 할 때 서버 측에서 CORS 설정이 필요할 수 있다.

CORS 통신을 하게 되면 네트워크 탭에서 OPTIONS 요청이 추가로 발생한다.

이 요청은 실제 데이터를 전송하는 요청이 아니고 실제 요청 전에 서버에 안전하게 요청을 보낼 수 있는지 확인하는 **"프리플라이트"** 요청이다.

보통 프론트에서는 헤더에 `WithCredentials: true`와 함께 리퀘스트를 보내고, 백엔드에서는 `Access-Control-Request-Method`와 `Access-Control-Request-Headers`를 포함하여 리스폰스를 보낸다.

### CORS를 겪고 직접 해결해 본 경험이 있으면 말해주세요

개발환경과 실제 배포환경에서 해결하는 방식으로 나누어보자.

1. 개발환경

   package.json에서 프록시 설정을 변경하여 해결할 수 있다.

   ```json
   {
     "name": "your-project-name",
     "version": "1.0.0",
     "private": true,
     "dependencies": {
       // ... 다른 의존성들 ...
     },
     "scripts": {
       // ... 스크립트들 ...
     },
     "proxy": "http://api.example.com"
   }
   ```

   위와 같이 설정하면 api요청이 프록시를 통해서 전달된다. 하지만 위 방법은 개발 환경에서만 동작을 하기 때문에 실 배포에서는 사용할 수 없는 방법.

2. 실제 배포환경

   1. 서버에서 허용해주는 방법
   2. 프록시 서버를 사용하는 방법

   위 두가지 방법으로 나뉜다.

   1. 서버에서 허용해주는 방법

      서버에서 허용해주는 방법은 서버에서 허용할 오리진을 명시해주는 방법이다.
      Nest에서는 다음과 같이 서버에서 허용할 수 있다.

      ```typescript
      // main.ts
      import { NestFactory } from "@nestjs/core";
      import { AppModule } from "./app.module";

      app.enableCors({
        origin: ["http://localhost:3000"],
      });

      bootstrap();
      ```

   2. 프록시 서버를 사용하는 방법

      이 방법은 서버와 서버간에는 CORS가 발생하지 않기 때문에 중간에 프록시서버를 두고 이를 통해 요청을 넣는 방법이다.

      Nginx를 사용하여 프록시 서버를 구축할 수 있다. 또는 헤로쿠에서도 프록시 서버를 구축할 수 있다. Next.js에서도 서버 api를 사용할 수 있기 때문에 프록시 역할을 하는 서버를 구축할 수 있다.

## CDN

### `CDN이란 뭔가요?`

**CDN(Content Delivery Network): 콘텐츠 전송 네트워크**

서버의 물리적인 위치와 사용자가 접속하는 위치는 동일할 수 도, 다를 수도 있다. 당연히 멀 경우에는 네트워크 지연이 발생 할 수 있기 때문에 전송 속도가 늦을 수 있다.

> 왜 물리적 위치가 멀 경우에는 네트워크 지연이 발생할 수 있을까?
>
> 1. 데이터는 전기나 빛의 형태로 전송되기 때문에 물리적인 거리가 영향을 준다.
> 2. 데이터는 여러 라우터, 스위치, 중계기를 통과하기 때문에 장비마다 데이터를 처리하고 전달하는 시간이 필요하다.
> 3. 긴 거리의 네트워크는 더 많은 사용자와 트래픽을 처리한다.
> 4. 긴 거리의 통신에는 추가적인 프로토콜 레이어가 필요할 수 있다.

CDN은 이런 문제를 해결하기 위해 사용된다.

1. 페이지 로드 시간 단축

2. 대역폭 비용 절감

   캐싱 및 기타 최적화를 통해 CDN은 오리진 서버가 제공해야하는 데이터 양을 줄여 비용을 절감할 수 있다.

3. 콘텐츠 가용성 재고

   한번에 많은 방문자가 방문하는 경우 오리진 서버에 부하가 걸리기 때문에 중간에 CDN 서버를 두어 부하를 분산할 수 있다. 하나이상의 CDN 서버가 오프라인으로 전환되면 다른 운영서버가 해당 서버를 대체하여 서비스가 중단되지 않도록 할 수 있다.

4. 웹 사이트 보안 강화
   DDoS 공격을 중간 서버 간에 분산하여 오리진 서버에 가해지는 부담을 줄인다.

CDN이 동작하는 원리는 다음과 같다.

1. 사용자가 최초로 사이트에서 정적 웹 콘텐츠를 요청한다.
2. 요청이 웹 애플리케이션 서버로 도달한다. 서버는 사용자에게 응답을 보내는 동시에 지리적으로 가까운 **CDN POP(접속 지점, Points of Presence)**에 응답 복사본을 보낸다.
3. CDN POP 서버는 복사본을 캐싱된 파일로 저장한다.
4. 다음에 해당 방문자 또는 해당 위치에 있는 다른 방문자가 동일한 요청을 하면, 오리진 서버가 아닌 캐싱서버에서 응답을 보낸다.

사용할 수 있는 예시는 다음과 같다.

- 넷플릭스, 유튜브와 같은 고용량 고화질 동영상 플랫폼
- 게임의 업데이트 파일
- 슬랙의 메시지나 파일을 캐싱, 웹소켓연결을 위한 엣지 서버로 사용

AWS에서는 Amazon CloudFront라는 CND 서비스를 제공한다.

## 쿠키 세션

### 쿠키, 세션을 왜 쓰나요?

브라우저에 사용자의 **정보를 저장**하기 위해서

기본적으로 브라우저에 있는 데이터들은 서버에 전달되어 외부 DB에 백업 되어있지 않는 한, 브라우저를 닫으면 사라지게 된다. 따라서 브라우저 내에 정보를 저장하기 위해 사용하는 것이 쿠키이다.

세션의 경우에는 서버에 저장되는 것,

### 쿠키가 뭔가요?

쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각을 의미한다.

브라우저는 그 데이터 조각을 저장해 놓았다가, 동일한 서버에 재 요청시 쿠키를 함께 전송한다.

물론 서버뿐만 아니라 클라이언트에서도 쿠키를 생성해 브라우저에 저장하는 것이 가능하다.

#### 쿠키 생성 방법

1. Set-Cookie
   서버에서 응답을 보낼 때 응답의 헤더에 Set-Cookie를 포함하여 응답을 보내면 클라이언트에서는 해당 요청을 받고 쿠키를 생성한다.

   이 때 쿠키는 서버에서 전송한 쿠키의 속성에 따라 다양하게 설정이 된다.
   origin, path, expires, secure, httpOnly 등이 있다.

   > origin: 쿠키를 생성한 도메인
   >
   > path: 쿠키가 저장될 경로
   >
   > expires: 쿠키의 만료 시간
   >
   > secure: 쿠키가 전송될 때 HTTPS 프로토콜만 사용
   >
   > httpOnly: 브라우저의 스크립트로 쿠키에 접근하는 것을 방지
   >
   > domain: 쿠키가 전송될 도메인

   현재 브라우저는 서드 파티 쿠키를 제한하는 정책을 가지고 있다.
   서드 파티 쿠키란 다른 도메인의 쿠키를 말하는데, 이를 제한하는 이유는 보안상의 이유 때문이다.

2. 브라우저의 쿠키 저장소에 직접 저장
   ```javascript
   document.cookie =
     "name=value; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/";
   ```
   다만 이때는 HttpOnly 속성이 적용되지 않는다.

#### 쿠키의 특징

- 이름, 값, 만료일, 경로(path) 로 구성되어 있음
- 클라이언트에 300개 제한
- 하나의 도메인 당 20개의 쿠키 제한
- 하나의 쿠키는 4KB까지 저장 가능

#### 쿠키의 동작 순서

1. 서버에서 Set-Cookie 헤더를 통해서 브라우저에 쿠키를 설정
2. 브라우저는 쿠키 저장소에 쿠키를 저장
3. 동일 사이트 방문 혹은 동일 도메인 요청 시 브라우저는 요청의 헤더에 쿠키를 함께 담아 전송

#### 쿠키 사용 예시

- JWT의 리프레시 토큰과 같이 서버에 주기적으로 보내야하는 요청
- I18n의 국제화 설정
- 팝업 창의 오늘 보지 않기 설정
- 자동 로그인 같은 설정

#### 쿠키의 약점

httpOnly를 설정하지 않은 경우 스크립트를 통해 쿠키를 탈취할 수 있음.
Secure를 설정하지 않으면 Http로도 흘러들어갈 수 있기 때문에 통신 과정에서 통신을 탈취당하면 헤더에 담긴 정보가 고스란히 노출될 수 있다.
여러모로 XSS, CSRF 공격에 취약하다.

### 세션이 뭔가요?

세션은 클라이언트가 웹 서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 통신을 끝낼 때 까지의 기간을 의미한다.

하지만 보통 세션의 경우에는 서버에 세션에 대한 정보를 저장하고, 세션 쿠키를 클라이언트에게 주어 서버가 클라이언트를 식별할 수 있도록 하는 방식을 의미한다.

기본적으로 백엔드에서 세션을 저장할 때는 메모리에 저장하지만, 메모리에 저장하는 것은 서버의 메모리 용량에 따라 한계가 있기 때문에 데이터베이스에 저장하는 경우가 많다.

이 때 사용되는 것이 Redis와 같은 캐시 서버이다. 이 때는 브라우저 연결 종료시 자동으로 삭제되지는 않고, 설정된 만료 시간까지 레디스에 유지된다.

예를 들어 로그인 상태를 유지하는 경우 세션에 사용자의 정보를 저장하고, 세션 쿠키를 통해 서버에 전달하는 방식으로 사용된다. 이 때 로그아웃 요청을 하면 세션에 저장된 정보를 삭제하고 세션 쿠키를 삭제하는 방식으로 사용된다.

레디스를 사용한다면 로그아웃 요청이 들어올때 세션에 저장된 정보를 삭제하게 된다.

### 쿠키와 세션의 차이는 어떤 점이 있을까요?

쿠키는 클라이언트, 세션은 서버

쿠키는 보안상 취약점이 있을 수 있고 세션은 서버에서 처리하기 때문에 비교적 안전하다.

쿠키는 클라이언트에 저장되어 서버 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 느리다.

### JWT을 아나요?

JWT(JSON Web Token)
JSON 객체를 사용하여 사용자 인증 정보나 다른 데이터들을 전송하는 방식.

#### JWT 생성 방법

JSON을 생성하는 방식은 다음과 같다.

1. DB에 저장된 사용자의 정보를 불러온다.
2. 사용자의 정보를 JSON 형식의 객체로 변환한다.
3. 변환된 객체를 암호화하여 토큰을 생성한다.
4. 이를 클라이언트에 전달하고 이후 클라이언트는 요청마다 토큰을 헤더에 담아 전송한다.
5. 서버에서는 토큰을 검증하여 사용자의 인증 정보를 확인한다.

#### JWT 형식

JSON의 형식은 다음과 같다.

- 헤더
- 페이로드
- 시그니쳐

1. 헤더
   헤더는 토큰의 유형(JWT)와 해싱 알고리즘(SHA256, RSA)를 지정한다.
2. 페이로드
   페이로드는 토큰에 담을 데이터를 의미한다.
   해당 데이터는 사용자의 이름, 이메일, 권한과 같이 인증에 필요한 혹은 서버에서 추가로 데이터를 불러오지 않기 위해 집어넣은 정보들이 담긴다.
   해당 데이터는 암호화를 하지않고 Base64 방식으로 인코딩이 되어있어 민감한 정보를 담지 않는 것이 좋다.
   또한 페이로드에는 생성 시간, 만료 시간, 발급자, 대상자 등의 정보가 들어가는 것이 좋다.
3. 시그니쳐
   시그니쳐는 헤더와 페이로드를 합친 후 암호화하여 생성한다.
   이 때 사용되는 알고리즘은 헤더에 지정한 알고리즘을 사용한다.
   이 때 사용되는 비밀키는 서버에서 관리하는 비밀키를 사용한다.

### JWT를 웹 스토리지에 저장해야 한다면 어디다 저장하시겠나요? 이유는요?

여러가지 방안이 있을 수 있으며 그에 따라 장 단점이 있다.

1. 쿠키
   쿠키의 경우 서버 단에서 set-cookie 헤더를 통해 전달할 수 있다. 혹은 브라우저에서 직접 저장할 수 있다.

   서버의 도메인을 공유하는 경우, 혹은 서브 도메인, 포트 등이 다른 경우에는 클라이언트의 요청에 자동으로 쿠키가 전달 되기 때문에 클라이언트 측에서는 오히려 편할 수도 있다.

   쿠키의 경우에는 httpOnly 속성을 설정하여 스크립트로 쿠키에 접근하는 것을 방지할 수 있다.

   또한 만료시간을 설정하여 그 시간이 지나면 쿠키가 자동으로 삭제되기 때문에 보안상 안전할 수 있다.

   그러나 쿠키의 경우 요청에 자동으로 포함되기 때문에 중간에 통신이 탈취당하면 헤더에 담긴 정보가 고스란히 노출될 수 있다.

2. 로컬 스토리지 & 세션 스토리지
   웹 스토리지의 경우 서버에서 JWT를 응답에 포함시켜 보내주면 클라이언트에서 로컬스토리지 혹은 세션스토리지에 저장해서 요청마다 헤더의 authorization 혹은 bearer 토큰에 담아 전송할 수 있다.

   모든 요청이 아니라 특정 요청에서만 사용하는 경우를 설정할 수 있기 때문에 통신이 중간에 탈취당해 보안이 침해될 확률이 쿠키보다는 적을 수 있다.

   하지만 웹 스토리지의 경우에는 스크립트를 통해 토큰이 탈취당할 수 있기 때문에 이 부분에서는 쿠키보다 보안이 떨어진다.

   웹 스토리지의 경우에는 두가지로 분류가 되는데

   1. 로컬 스토리지
   2. 세션 스토리지

   로컬 스토리지는 만료 시간이 없기 때문에 직접 삭제해주지 않는 이상 브라우저를 닫을 때까지 유지된다.
   세션 스토리지는 브라우저를 닫을 때 삭제된다. 따라서 보안이 보다 중요한 경우에는 세션스토리지를 이용해서 브라우저를 닫을 시 토큰을 삭제하는 편이 좋다.


## 웹팩

### 웹팩이란?

여러가지 모듈을 하나의 파일로 번들링(Bundling)하는, 하나의 꾸러미로 만들어주는 역할을 한다.

이렇게 번들링된 파일은 웹서버에서 정적파일로 제공된다.

보통 react나 next.js에서 build 명령어를 실행하게되면 웹팩, 터보팩이 프로젝트를 번들링한다.

이런 번들링을 통해 파일 크기가 최적화, 코드 스플리팅으로 초기 로딩시간 감소 등의 이점을 얻을 수 있다.

### 모듈이란?

프로그래밍 관점에서는 특정 기능을 갖는 작은 코드 단위를 의미한다.

웹팩에서 지칭하는 모듈이라는 개념은 자바스크립트 모듈 뿐만 아니라 웹 애플리케이션을 구성하는 모든 자원을 의미한다.

HTML, CSS, JS, Image, Font 등 모든 자원이 모듈이 될 수 있다.

### 모듈 번들링이란?

위에서 말한 모듈을 하나의 파일로 병합 및 압축 해주는 동작을 모듈 번들링이라고 한다.

### 웹팩이 등장한 이유 웹팩 사용 시에 이점

#### 웹팩이 필요한 이유

웹팩이 등장한 배경은 크게 3가지로 나눌 수 있다.

`파일 단위의 자바스크립트 모듈 관리의 필요성`

자바스크립트의 변수 유효범위는 기본적으로 전역을 범위로 갖는다. 최대한 넓은 변수 범위를 갖기 때문에 어디서도 접근이 편리하다.

하지만 다시말해 변수 범위가 넓기 때문에 변수 충돌이 발생할 수 있다.

따라서 파일 단위로 변수를 관리하고 싶은 욕구, 자바스크립트 모듈화에 대한 욕구가 생겨났다.


`웹 개발 작업 자동화 도구 (Web Task Manager)`

IDE에서 코드를 수정하고 저장한 뒤 브라우저에서 새로고침을 해야 변경된 내용을 볼 수 있었다.

이외에도
- HTML, CSS, JS 압축
- 이미지 압축
- CSS 전처리기 변환

이런 일들을 자동화해주는 도구들이 필요했다.

`웹 애플리케이션의 빠른 로딩 속도와 높은 성능`

일반적으로 특정 웹사이트를 접근할 때 5초 이내로 사이트가 표시되지 않으면 집중력을 잃게된다.

따라서 로딩속도를 높이기 위해서 대표적으로 서버로 요청하는 파일 숫자를 줄이는 것. 이를 위해 웹 태스크 매니저를 통해서 파일을 압축하고 병합하는 작업을 진행했다.

뿐만 아니라 초기 페이지 로딩속도를 높이기 위해서 나중에 필요한 자원들은 나중에 요청하는 레이지 로딩이 등장했다.

웹팩은 기본적으로 필요한 자원은 미리 로딩하는게 아니라 그 때 그 때 요청하자는 철학을 가지고 있다.

#### 웹팩이 해결하려는 문제

`자바스크립트 변수 유효 범위`

웹팩은 변수 유효 범위의 문제점을 ES6 모듈 문법과 웹팩의 모듈 번들링으로 해결합니다.

1. IIFE(즉시 실행 함수)사용
   - 각 모듈을 독립적인 함수 스코프로 감싸준다.
   - 모듈별로 독립된 스코프를 생성한다.

2. 모듈 시스템 구현

3. 코드 분리와 캐싱
   - 각 모듈을 개별적으로 관리
   - 모듈간의 의존성을 명확하게 추적
   - 중복 로드 방지를 위한 캐싱 구현

4. ES6 모듈과 시너지
   - 브라우저 호환성 보장
   - 효율적인 번들링
   - 트리 쉐이킹 지원

`브라우저별 HTTP 요청 숫자의 제약`

TCP 스펙에 따라 브라우저에서 한번에 서버로 보낼 수 있는 요청 숫자는 제한되어있다.
따라서 HTTP 요청 숫자를 줄이는 것이 웹 애플리케이션의 성능을 높여줄 뿐만 아니라 사용자가 사이트를 조작하는 시간을 앞당겨 줄 수 있다.

`사용하지 않는 코드 관리`

`Dynamic Loading & Lazy Loading 미지원`

웹팩의 코드 스플리팅 기능을 사용해 원하는 모듈을 원하는 타이밍에 로딩할 수 있다.

#### 코드 스플리팅?

애플리케이션 번들을 여러 개의 작은 청크로 나누는 프로세스다.

이를 통해 초기 로딩 시간 감소, 필요한 시점에 필요한 코드만 로드, 리소스의 효율적 사용이 가능하다.

### 바벨이란?

자바스크립트의 최신 문법으로 작성한 코드를 웹 브라우저와의 호환을 위해 이전 버전의 문법으로 재작성하는 역할을 하는 프로그램.


### 웹팩의 주요 속성 4가지

1. entry

entry 속성은 웹팩에서 웹 자원을 변환하기 위해 필요한 최초 진입점이자 자바스크립트 파일 경로.

`빌드를 할 대상 파일의 위치` 라고 볼 수 있다.

```js
// webpack.config.js
module.exports = {
  entry: './src/index.js',
};
```

entry 속성에 지정된 파일에는 웹 애플리케이션의 전반적인 구조와 내용이 담겨져 있어야 한다.

웹팩이 해당 파일을 가지고 웹 애플리케이션에서 사용되는 모듈들의 연관관계를 이해하고 분석하기 때문에 애플리케이션을 동작시킬 수 있는 내용들이 담겨져 있어야한다.

SPA의 경우 index.js 파일을 예시로 들면

```js
// index.js
import LoginView from './LoginView.js';
import HomeView from './HomeView.js';
import PostView from './PostView.js';

function initApp() {
  LoginView.init();
  HomeView.init();
  PostView.init();
}

initApp();
```

위와 같은 형식으로 로그인, 메인, 게시글 작성 등 웹서비스에서 필요한 화면들이 index.js파일에서 불러져 사용된다.

다만 entry의 경우 엔트리 포인트가 1개가 될 수도 있지만 아래와 같이 여러 개가 될 수도 있다.

여러개로 설정하는 경우 SPA가 아닌 특정 페이지로 진입했을 때 서버에서 해당 정보를 내려주는 형태의 멀티 페이지 어플리케이션이 된다.

#### Next.js와 MPA의 차이점

전통적인 MPA는 각 페이지마다 새로운 HTML을 서버에서 받아오고, 페이지 전환 시 전체 페이지를 리로드, 각 페이지별로 독립적인 JS를 번들한다.

하지만 next.js는 React Server Component 기반, 클라이언트 사이드 라우팅을 유지, 서버 컴포넌트와 클라이언트 컴포넌트의 하이브리드 렌더링을 사용한다.

데이터 패칭의 경우 서버 패칭은 서버컴포넌트에서 직접 패칭하며, 스트리밍, 부분적 데이터로딩을 지원한다.

MPA의 장점인 서버 사이드 렌더링, SPA의 장점인 네비게이션을 유지하며, RSC를 통한 새로운 렌더링 방식이다.

2. output

output 속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미한다.

filename을 지정해야하며 일반적으로 path 속성을 함께 정의한다.

보통 dist 폴더에 저장한다.

3. loader

로더는 웹팩이 웹 애플리케이션을 해석할 때 자바스크립트 파일이 아닌 웹자원(HTML, CSS, Images, font 등)을 빌드시에 자바스크립트의 output 파일에 포함 될 수 있도록 도와주는 속성이다.

만약 로더가 없는 경우에는 알아볼 수 없는 파일 형식자인 css가 포함되어 이를 해석할 수 없다는 에러를 발생시킨다.

4. plugin

웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성이다.

로더와 비교하자면 로드는 파일을 해석하고 변환하는 과정에 관여하고, 플러그인은 해당 결과물의 형태를 바꾸는 역할을 한다.